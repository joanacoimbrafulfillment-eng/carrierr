<!DOCTYPE html>
<html lang="pt">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Crosscheck Transportadoras ↔ OFF (Ligação Direta)</title>

  <!-- Firebase (compat) -->
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>

  <style>
    :root{
      --bg:#0b1220;
      --panel:#0f1b33;
      --card:#101f3d;
      --muted:#9fb0d0;
      --text:#e8eefc;
      --accent:#5aa7ff;
      --ok:#2ecc71;
      --bad:#ff5c6c;
      --warn:#ffb020;
      --line: rgba(255,255,255,.08);
      --chip: rgba(90,167,255,.18);
    }
    *{box-sizing:border-box}
    body{margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; background:linear-gradient(180deg,#070b14, var(--bg)); color:var(--text);}
    .wrap{max-width:1300px; margin:0 auto; padding:18px;}
    .topbar{
      display:flex; gap:12px; align-items:center; justify-content:space-between;
      padding:14px 16px; border:1px solid var(--line); background:rgba(15,27,51,.55);
      border-radius:16px; position:sticky; top:10px; backdrop-filter: blur(10px); z-index:20;
    }
    .brand{display:flex; gap:10px; align-items:center;}
    .logo{width:38px; height:38px; border-radius:12px; background:linear-gradient(135deg,var(--accent),#9a5bff); box-shadow:0 10px 30px rgba(90,167,255,.25);}
    .brand h1{margin:0; font-size:16px; letter-spacing:.4px;}
    .brand .sub{margin:0; font-size:12px; color:var(--muted)}
    .row{display:flex; gap:14px; flex-wrap:wrap; align-items:center;}
    .btn{
      border:1px solid var(--line); background:rgba(255,255,255,.04); color:var(--text);
      padding:10px 12px; border-radius:12px; cursor:pointer; font-weight:800; letter-spacing:.3px;
    }
    .btn.primary{background:linear-gradient(135deg,var(--accent),#4a7dff); border:none;}
    .btn.danger{background:rgba(255,92,108,.18); border:1px solid rgba(255,92,108,.35);}
    .btn:disabled{opacity:.55; cursor:not-allowed}
    .pill{padding:6px 10px; border-radius:999px; background:rgba(255,255,255,.05); border:1px solid var(--line); color:var(--muted); font-size:12px; font-weight:800;}
    .grid{display:grid; grid-template-columns: 1.1fr .9fr; gap:14px; margin-top:14px;}
    @media (max-width: 980px){ .grid{grid-template-columns:1fr;} }
    .card{
      border:1px solid var(--line); background:rgba(16,31,61,.55);
      border-radius:16px; padding:14px; box-shadow:0 16px 40px rgba(0,0,0,.25);
    }
    .card h2{margin:0 0 10px 0; font-size:14px; color:#dbe6ff; letter-spacing:.4px;}
    label{display:block; font-size:12px; color:var(--muted); font-weight:800; margin:8px 0 6px;}
    input, select, textarea{
      width:100%; padding:10px 12px; border-radius:12px; border:1px solid var(--line);
      background:rgba(0,0,0,.25); color:var(--text); outline:none;
    }
    textarea{min-height:120px; resize:vertical; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;}
    .mini{font-size:11px; color:var(--muted);}
    .split{display:grid; grid-template-columns: 1fr 1fr; gap:10px;}
    @media (max-width: 640px){ .split{grid-template-columns:1fr;} }
    .dash{display:grid; grid-template-columns: repeat(4, 1fr); gap:10px;}
    @media (max-width: 900px){ .dash{grid-template-columns: repeat(2, 1fr);} }
    .kpi{padding:12px; border-radius:14px; border:1px solid var(--line); background:rgba(0,0,0,.18);}
    .kpi .n{font-size:26px; font-weight:900; margin:0;}
    .kpi .t{margin:6px 0 0; color:var(--muted); font-size:12px; font-weight:900; letter-spacing:.3px; text-transform:uppercase;}
    .ok{color:var(--ok)} .bad{color:var(--bad)} .warn{color:var(--warn)}
    .tableWrap{overflow:auto; border:1px solid var(--line); border-radius:14px;}
    table{width:100%; border-collapse:collapse; font-size:13px; min-width:980px;}
    th, td{padding:10px 10px; border-bottom:1px solid rgba(255,255,255,.06); text-align:left; vertical-align:top;}
    th{position:sticky; top:0; background:rgba(10,16,30,.96); color:#cfe0ff; z-index:2;}
    tr:hover td{background:rgba(90,167,255,.06);}
    .chip{display:inline-flex; align-items:center; gap:8px; padding:6px 10px; border-radius:999px; background:var(--chip); border:1px solid rgba(90,167,255,.35); font-weight:900; font-size:12px;}
    .status{font-weight:900;}
    .status.PACKED{color:var(--ok)}
    .status.PENDING{color:var(--warn)}
    .status.CANCELLED{color:var(--bad)}
    .muted{color:var(--muted)}
    .link{color:#cfe0ff; text-decoration:underline; cursor:pointer; font-weight:900;}
    .modal{
      display:none; position:fixed; inset:0; background:rgba(0,0,0,.75); z-index:50; padding:18px;
      align-items:center; justify-content:center;
    }
    .modal .box{
      width:min(1100px, 96vw); max-height: 92vh; overflow:auto;
      background:rgba(16,31,61,.98); border:1px solid var(--line); border-radius:18px; padding:16px;
      box-shadow:0 30px 90px rgba(0,0,0,.55);
    }
    .modal h3{margin:0; font-size:16px;}
    .hr{height:1px; background:rgba(255,255,255,.08); margin:12px 0;}
    .cols{display:grid; grid-template-columns: 1.1fr .9fr; gap:12px;}
    @media (max-width: 980px){ .cols{grid-template-columns:1fr;} table{min-width:780px;} }
    .mono{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;}
    .tag{display:inline-block; margin:4px 6px 0 0; padding:6px 10px; border-radius:999px; border:1px solid var(--line); background:rgba(255,255,255,.05); font-weight:800; font-size:12px;}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="topbar">
      <div class="brand">
        <div class="logo"></div>
        <div>
          <h1>Crosscheck Transportadoras ↔ OFF</h1>
          <p class="sub">Liga diretamente à base de dados do OFF (Firebase) e cruza com IDs colados das transportadoras.</p>
        </div>
      </div>
      <div class="row">
        <span id="authState" class="pill">Não autenticado</span>
        <button id="btnOpenLogin" class="btn">Login</button>
        <button id="btnLogout" class="btn danger" style="display:none;">Logout</button>
        <button id="btnClearAll" class="btn danger" title="Apaga listas guardadas e resultados (não altera o OFF)">Apagar tudo</button>
        <button id="btnExportLists" class="btn" title="Exporta as listas (ficheiro JSON)">Exportar listas</button>
        <button id="btnImportLists" class="btn" title="Importa listas (JSON)">Importar listas</button>
        <input id="importFile" type="file" accept=".json" style="display:none;" />
      </div>
    </div>

    <div class="grid">
      <div class="card">
        <h2>1) IDs das Transportadoras (colar)</h2>
        <div class="split">
          <div>
            <label>Transportadora</label>
            <select id="carrierSel"></select>
            <div class="mini">Cria dashboards por transportadora (CTT / NACEX / CORREOS / ...)</div>
          </div>

          <div>
            <label>Transportadoras a cruzar (seleciona 2+ se quiseres)</label>
            <select id="carrierMulti" multiple size="6"></select>
            <div class="row" style="margin-top:8px;">
              <button class="btn" type="button" onclick="selectAllCarriers()">Selecionar todas</button>
              <button class="btn" type="button" onclick="selectNoneCarriers()">Limpar seleção</button>
            </div>
            <div class="mini">O cruzamento usa só as transportadoras selecionadas. Se não selecionares nenhuma, usa todas com lista guardada.</div>
          </div>

          <div>
            <label>Adicionar transportadora (opcional)</label>
            <div class="split">
              <input id="newCarrier" placeholder="Ex: DHL" />
              <button class="btn" onclick="addCarrierLocal()">Adicionar</button>
            </div>
            <div class="mini">Isto só é local neste ficheiro (não altera o OFF).</div>
          </div>
        </div>

        <label>Colar IDs (um por linha, ou separados por espaços/vírgulas)</label>
        <textarea id="carrierIds" placeholder="12345678&#10;87654321"></textarea>
        <label>Lista conjunta (para 2+ transportadoras selecionadas, ex: CORREOS ES + CORREOS PT)</label>
        <textarea id="jointIds" placeholder="Cola aqui a lista única (opcional). Se tiver IDs, esta lista é usada para a seleção de transportadoras."></textarea>
        <div class="mini">Quando selecionas 2+ transportadoras e colas aqui, não precisas duplicar listas por carrier.</div>

        <div class="row" style="justify-content:space-between; margin-top:10px;">
          <div class="mini">Dica: podes colar várias vezes; o sistema guarda por transportadora.</div>
          <div class="row">
            <button class="btn" onclick="saveCarrierPaste()">Guardar lista</button>
            <button class="btn" onclick="clearCarrierPaste()">Limpar lista</button>
          </div>
        </div>

        <div class="hr"></div>

        <h2>2) Janela de datas + tolerância</h2>
        <div class="split">
          <div>
            <label>Data inicial</label>
            <input type="date" id="startDate">
          </div>
          <div>
            <label>Data final</label>
            <input type="date" id="endDate">
          </div>
        </div>
        <div class="split">
          <div>
            <label>Tolerância (dias antes)</label>
            <select id="lookback">
              <option value="0">0</option>
              <option value="1" selected>1</option>
              <option value="2">2</option>
              <option value="3">3</option>
              <option value="7">7</option>
            </select>
            <div class="mini">Ex: se o ID só aparece na transportadora no dia seguinte, usa 1 (default).</div>
          </div>
          <div>
            <label>Modo de procura</label>
            <select id="searchMode">
              <option value="FAST" selected>Rápido (active_batches + registos só do intervalo)</option>
              <option value="DEEP">Profundo (inclui id_history + pode demorar)</option>
            </select>
            <div class="mini">Profundo é útil quando o ID foi re-criado/cancelado e queres ver tudo.</div>
          </div>
        </div>

        <div class="row" style="margin-top:12px;">
          <button id="btnRun" class="btn primary" onclick="run()">Cruzamento / Atualizar dashboard</button>
          <span id="runStatus" class="pill">Pronto</span>
        </div>

        <div class="hr"></div>

        <h2>3) Carregar transportadoras do OFF (opcional)</h2>
        <div class="mini">Se tiveres acesso, podemos ler <span class="mono">config/carriers</span> do OFF para preencher a lista automaticamente.</div>
        <div class="row" style="margin-top:10px;">
          <button class="btn" onclick="loadCarriersFromOFF()">Ler transportadoras do OFF</button>
          <span id="carrierLoadStatus" class="mini"></span>
        </div>

      </div>

      <div class="card">
        <h2>Dashboard</h2>
        <div class="dash">
          <div class="kpi">
            <p class="n" id="kpiTotal">0</p>
            <p class="t">IDs colados (total)</p>
          </div>
          <div class="kpi">
            <p class="n ok" id="kpiMatch">0</p>
            <p class="t">Bate certo</p>
          </div>
          <div class="kpi">
            <p class="n bad" id="kpiMissing">0</p>
            <p class="t">Não encontrado</p>
          </div>
          <div class="kpi">
            <p class="n warn" id="kpiOther">0</p>
            <p class="t">Encontrado noutra carrier</p>
          </div>
        </div>

        <div class="hr"></div>
        <div class="dash" style="margin-top:10px;">
          <div class="kpi">
            <p class="n" id="kpiOffSel">0</p>
            <p class="t">IDs no OFF (seleção)</p>
          </div>
          <div class="kpi">
            <p class="n bad" id="kpiOffMissing">0</p>
            <p class="t">IDs OFF que faltam na lista</p>
          </div>
          <div class="kpi">
            <p class="n ok" id="kpiOffInList">0</p>
            <p class="t">IDs OFF presentes na lista</p>
          </div>
          <div class="kpi">
            <p class="n" style="font-size:14px; line-height:1.2;" id="kpiOffCarriers">—</p>
            <p class="t">Carriers usadas</p>
          </div>
        </div>
        <div class="row" style="margin-top:10px;">
          <button class="btn" onclick="openOffMissing()">Ver IDs OFF que não vieram na lista</button>
          <button class="btn" onclick="openOffAll()">Ver TODOS os IDs do OFF (seleção)</button>
        </div>


        <div class="split">
          <div>
            <label>Filtrar tabela</label>
            <input id="filterText" placeholder="ex: 12345678, CTT, PACKED, lote..." oninput="renderTable()" />
          </div>
          <div>
            <label>Mostrar</label>
            <select id="filterKind" onchange="renderTable()">
              <option value="ALL">Tudo</option>
              <option value="MATCH">Só bate certo</option>
              <option value="MISSING">Só não encontrado</option>
              <option value="OTHER_CARRIER">Só outra carrier</option>
            </select>
          </div>
        </div>
        <div class="row" style="justify-content:space-between; margin-top:10px;">
          <button class="btn" onclick="clearFilters()">Limpar filtros</button>
          <span id="activeFilters" class="pill">Sem filtros</span>
        </div>


        <div class="hr"></div>

        <div class="tableWrap">
          <table>
            <thead>
              <tr>
                <th>Carrier (input)</th>
                <th>ID</th>
                <th>Resultado</th>
                <th>Carrier no OFF</th>
                <th>Status no OFF</th>
                <th>Lote</th>
                <th>Data do Lote</th>
                <th>Packed?</th>
                <th>Tracking</th>
                <th>Detalhes</th>
              </tr>
            </thead>
            <tbody id="tbody"></tbody>
          </table>
        </div>

        <div class="hr"></div>
        <div class="mini">
          Nota: “Status no OFF” vem do lote: <span class="mono">CANCELLED</span> se estiver em <span class="mono">cancelled_ids</span>, 
          <span class="mono">PACKED</span> se estiver em <span class="mono">processed_ids</span>, senão <span class="mono">PENDING</span>.
        </div>
      </div>
    </div>
  </div>

  <!-- LOGIN MODAL -->
  <div id="loginModal" class="modal">
    <div class="box">
      <div class="row" style="justify-content:space-between;">
        <h3>Login no OFF (Firebase)</h3>
        <button class="btn danger" onclick="closeLogin()">Fechar</button>
      </div>
      <div class="hr"></div>
      <div class="cols">
        <div>
          <label>Email</label>
          <input id="loginEmail" type="email" placeholder="ex: utilizador@admin.com / utilizador@wh.com"/>
          <label>Password</label>
          <input id="loginPass" type="password" placeholder="Password"/>
          <div class="row" style="margin-top:10px;">
            <button class="btn primary" onclick="doLogin()">Entrar</button>
            <span id="loginMsg" class="mini"></span>
          </div>
          <div class="hr"></div>
          <div class="mini">
            Este ficheiro liga ao mesmo Firebase do OFF (config embebida). Se o login falhar, é porque o utilizador não tem permissões no Firebase.
          </div>
        </div>
        <div>
          <h3 style="margin-top:0;">O que esta ligação vai buscar</h3>
          <div class="mini" style="line-height:1.6;">
            • <span class="mono">active_batches</span> (lotes criados, carrier, data, expected_ids, processed_ids, cancelled_ids, order_details)<br/>
            • <span class="mono">registos</span> (para apanhar tracking e confirmar PACKING)<br/>
            • Opcional: <span class="mono">id_history</span> (modo Profundo)
          </div>
        </div>
      </div>
    </div>
  </div>

  
  <!-- OFF LIST MODAL -->
  <div id="offListModal" class="modal">
    <div class="box">
      <div class="row" style="justify-content:space-between;">
        <h3 id="offListTitle">IDs OFF</h3>
        <button class="btn danger" onclick="closeOffList()">Fechar</button>
      </div>
      <div class="hr"></div>
      <div id="offListBody"></div>
    </div>
  </div>

  <!-- DETAILS MODAL -->
  <div id="detailModal" class="modal">
    <div class="box">
      <div class="row" style="justify-content:space-between;">
        <h3 id="detailTitle">Detalhe</h3>
        <button class="btn danger" onclick="closeDetail()">Fechar</button>
      </div>
      <div class="hr"></div>
      <div id="detailBody"></div>
    </div>
  </div>

<script>
  // ===== Firebase config (copiado do OFF) =====
  const firebaseConfig = {
    apiKey: "AIzaSyDExvgmtrSILCATQgE8ICJX-SVntb5lM2Y",
    authDomain: "wh-murtede.firebaseapp.com",
    databaseURL: "https://wh-murtede-default-rtdb.europe-west1.firebasedatabase.app",
    projectId: "wh-murtede",
    storageBucket: "wh-murtede.firebasestorage.app",
    messagingSenderId: "415946575714",
    appId: "1:415946575714:web:b1516b91b9735b9248e63b"
  };

  firebase.initializeApp(firebaseConfig);
  const auth = firebase.auth();
  const db = firebase.database();

  // ===== Local state =====
  const state = {
    carrierLists: {}, // { carrier: Set(ids) }
    carriers: ["CTT","NACEX","CORREOS ES","CORREOS PT"],
    results: [], // rows to render
    offIndex: new Map(), // id -> best match object
    offAllMatches: new Map(), // id -> array of matches (different carriers/batches)
    offCarrierIds: new Map(), // carrier -> Set(ids) (intervalo)
    offBatchesByCarrier: new Map(), // carrier -> Set(batchKey)

    packedIndex: new Map(), // id -> {tracking, packedAt, user, batchKey} from registos
    histIndex: new Map(), // id -> {events:[], summary:{} } from id_history (DEEP)
    lastRunMeta: {}
  };

  // ===== Persistência (localStorage) — só neste ficheiro / browser =====
  const LS_KEYS = {
    carriers: "crosscheck_off_carriers_v1",
    lists: "crosscheck_off_carrierLists_v1",
    joint: "crosscheck_off_jointIds_v1"
  };

  function saveToLocalStorage(){
    try{
      // carriers
      localStorage.setItem(LS_KEYS.carriers, JSON.stringify(state.carriers || []));
      // lists: convert Set -> Array
      const obj = {};
      Object.entries(state.carrierLists || {}).forEach(([c,set])=>{
        obj[c] = Array.from(set || []);
      });
      localStorage.setItem(LS_KEYS.lists, JSON.stringify(obj));
      // joint
      const jointEl = document.getElementById("jointIds");
      if(jointEl) localStorage.setItem(LS_KEYS.joint, String(jointEl.value||""));
    }catch(e){
      console.warn("Não consegui guardar no localStorage:", e);
    }
  }

  function loadFromLocalStorage(){
    try{
      const c = localStorage.getItem(LS_KEYS.carriers);
      const l = localStorage.getItem(LS_KEYS.lists);
      if(c){
        const carriers = JSON.parse(c);
        if(Array.isArray(carriers) && carriers.length){
          state.carriers = carriers.map(x=>String(x||"").trim().toUpperCase()).filter(Boolean);
        }
      }
      if(l){
      const obj = JSON.parse(l) || {};
        state.carrierLists = {};
        Object.entries(obj).forEach(([carrier, arr])=>{
          const cKey = String(carrier||"").trim().toUpperCase();
          const ids = Array.isArray(arr) ? arr.map(x=>String(x||"").trim()).filter(Boolean) : [];
          state.carrierLists[cKey] = new Set(ids);
        });
      }
    }catch(e){
      console.warn("Não consegui ler do localStorage:", e);
    }
  }

  function clearLocalStorageAll(){
    try{
      localStorage.removeItem(LS_KEYS.carriers);
      localStorage.removeItem(LS_KEYS.lists);
    }catch(e){}
  }

  function $(id){ return document.getElementById(id); }

  // ===== Helpers =====
  function safeKey(str){
    if(!str) return "UNKNOWN";
    return String(str).replace(/[.#$/[\]]/g, "_").trim().toUpperCase();
  }
  function parseIds(raw){
    if(!raw) return [];
    return String(raw)
      .split(/[\s,;]+/g)
      .map(s => s.trim())
      .filter(Boolean);
  }
  function uniq(arr){
    return Array.from(new Set(arr));
  }
  function fmt(v){ return (v===undefined || v===null) ? "" : String(v); }
  function dt(dateClean, time){ return (fmt(dateClean) + " " + fmt(time)).trim(); }
  function normTime(t){
    if(!t) return "";
    t = String(t).trim();
    if(/^\d{2}:\d{2}$/.test(t)) return t + ":00";
    if(/^\d{2}:\d{2}:\d{2}$/.test(t)) return t;
    if(t.length >= 8 && /^\d{2}:\d{2}:\d{2}/.test(t)) return t.slice(0,8);
    return t;
  }
  function dateAddDays(yyyy_mm_dd, delta){
    try{
      const d = new Date(yyyy_mm_dd + "T00:00:00");
      d.setDate(d.getDate() + delta);
      return d.toISOString().slice(0,10);
    }catch(e){
      return yyyy_mm_dd;
    }
  }
  function nowDate(){ return new Date().toISOString().slice(0,10); }
  function setStatus(txt, kind=""){
    const el = $("runStatus");
    el.textContent = txt;
    el.style.borderColor = "";
    if(kind==="ok") el.style.borderColor = "rgba(46,204,113,.45)";
    if(kind==="bad") el.style.borderColor = "rgba(255,92,108,.45)";
  }

  // ===== UI init =====
  function initDates(){
    const today = nowDate();
    $("startDate").value = dateAddDays(today, -1);
    $("endDate").value = today;
  }
  function renderCarrierSelect(){
    // dropdown (editar lista)
    const sel = $("carrierSel");
    sel.innerHTML = "";
    state.carriers.forEach(c => {
      const opt = document.createElement("option");
      opt.value = c; opt.textContent = c;
      sel.appendChild(opt);
    });
    if(!sel.value && state.carriers.length) sel.value = state.carriers[0];

    // multi-select (correr cruzamento)
    const ms = $("carrierMulti");
    if(ms){
      const prev = new Set(Array.from(ms.selectedOptions||[]).map(o=>o.value));
      ms.innerHTML = "";
      state.carriers.forEach(c=>{
        const opt = document.createElement("option");
        opt.value = c; opt.textContent = c;
        if(prev.size){
          opt.selected = prev.has(c);
        } else {
          const hasList = state.carrierLists && state.carrierLists[c] && state.carrierLists[c].size;
          opt.selected = !!hasList;
        }
        ms.appendChild(opt);
      });
    }

    loadCarrierPasteToBox();
  }
  function loadCarrierPasteToBox(){
    const c = $("carrierSel").value;
    const set = state.carrierLists[c] ? Array.from(state.carrierLists[c]) : [];
    $("carrierIds").value = set.join("\n");
  }
  $("carrierSel").addEventListener("change", loadCarrierPasteToBox);
  const ms = document.getElementById("carrierMulti");
  if(ms){ ms.addEventListener("change", ()=>{ try{ updateOffKPIs(); }catch(e){} }); }


  function addCarrierLocal(){
    const v = String($("newCarrier").value || "").trim().toUpperCase();
    if(!v) return;
    if(!state.carriers.includes(v)) state.carriers.push(v);
    state.carriers = state.carriers.filter(Boolean);
    state.carriers.sort();
    $("newCarrier").value = "";
    renderCarrierSelect();
    saveToLocalStorage();
  }
  window.addCarrierLocal = addCarrierLocal;

  function saveCarrierPaste(){
    const c = $("carrierSel").value;
    const ids = parseIds($("carrierIds").value);
    state.carrierLists[c] = new Set(ids);
    setStatus(`Guardado: ${c} (${ids.length} IDs)`, "ok");
    saveToLocalStorage();
  }
  window.saveCarrierPaste = saveCarrierPaste;

  function clearCarrierPaste(){
    const c = $("carrierSel").value;
    state.carrierLists[c] = new Set();
    $("carrierIds").value = "";
    setStatus(`Lista limpa: ${c}`, "ok");
    saveToLocalStorage();
  }
  window.clearCarrierPaste = clearCarrierPaste;

  function getSelectedCarriers(){
    const ms = $("carrierMulti");
    if(!ms) return [];
    return Array.from(ms.selectedOptions || []).map(o=>o.value).filter(Boolean);
  }

  function selectAllCarriers(){
    const ms = $("carrierMulti");
    if(!ms) return;
    Array.from(ms.options).forEach(o=> o.selected = true);
    setStatus("Selecionadas todas as transportadoras.", "ok");
  }
  window.selectAllCarriers = selectAllCarriers;

  function selectNoneCarriers(){
    const ms = $("carrierMulti");
    if(!ms) return;
    Array.from(ms.options).forEach(o=> o.selected = false);
    setStatus("Seleção limpa (se correres, usa todas com lista guardada).", "ok");
  }
  window.selectNoneCarriers = selectNoneCarriers;


  // ===== Auth UI =====
  function openLogin(){ $("loginModal").style.display="flex"; $("loginMsg").textContent=""; }
  function closeLogin(){ $("loginModal").style.display="none"; }
  $("btnOpenLogin").addEventListener("click", openLogin);
  window.closeLogin = closeLogin;

  async function doLogin(){
    const email = $("loginEmail").value;
    const pass = $("loginPass").value;
    $("loginMsg").textContent = "A autenticar...";
    try{
      await auth.signInWithEmailAndPassword(email, pass);
      $("loginMsg").textContent = "OK ✅";
      closeLogin();
    }catch(e){
      console.error(e);
      $("loginMsg").textContent = "Falhou (verifica credenciais/permissões).";
    }
  }
  window.doLogin = doLogin;

  $("btnLogout").addEventListener("click", async ()=>{
    await auth.signOut();
  });

  auth.onAuthStateChanged((user)=>{
    const pill = $("authState");
    const btnL = $("btnLogout");
    if(user){
      pill.textContent = "Autenticado: " + (user.email || "user");
      btnL.style.display = "inline-flex";
      $("btnOpenLogin").style.display = "none";
      // carregar lista de transportadoras diretamente do OFF (se tiver permissões)
      try{ loadCarriersFromOFF(); }catch(e){}

    } else {
      pill.textContent = "Não autenticado";
      btnL.style.display = "none";
      $("btnOpenLogin").style.display = "inline-flex";
    }
  });

  // ===== Load carriers from OFF (config/carriers) =====
  async function loadCarriersFromOFF(){
    $("carrierLoadStatus").textContent = "A carregar...";
    try{
      const snap = await db.ref("config/carriers").once("value");
      let carriers = snap.val() || [];
      if(!Array.isArray(carriers)) carriers = Object.values(carriers);
      carriers = carriers.map(x => String(x).trim().toUpperCase()).filter(Boolean);
      carriers = Array.from(new Set(carriers)).sort();
      if(carriers.length){
        // merge: manter carriers com listas guardadas mesmo que não existam no OFF
        const saved = Object.keys(state.carrierLists || {}).map(x=>String(x||"").trim().toUpperCase()).filter(Boolean);
        const merged = Array.from(new Set([...(carriers||[]), ...saved])).sort();
        state.carriers = merged;
        renderCarrierSelect();
        saveToLocalStorage();
        $("carrierLoadStatus").textContent = "OK ✅ (carregado do OFF: " + new Date().toLocaleString() + ")";
      }else{
        $("carrierLoadStatus").textContent = "Sem dados em config/carriers.";
      }
    }catch(e){
      console.error(e);
      $("carrierLoadStatus").textContent = "Erro (precisas de login/permissões).";
    }
  }
  window.loadCarriersFromOFF = loadCarriersFromOFF;

  // ===== Build OFF index from active_batches =====
  function statusFromBatch(b, id){
    const cancelled = b && b.cancelled_ids && b.cancelled_ids[id];
    if(cancelled) return "CANCELLED";
    const packed = b && b.processed_ids && b.processed_ids[id];
    if(packed) return "PACKED";
    return "PENDING";
  }

  function collectMatchesFromBatches(batches, start, end){
    const idx = new Map();       // id -> best match (prefer same day end, then latest date)
    const all = new Map();       // id -> []
    const byCarrierIds = new Map();
    const byCarrierBatches = new Map();
    const batchEntries = Object.entries(batches || {});
    batchEntries.forEach(([batchKey, b])=>{
      if(!b) return;
      const dc = fmt(b.dateClean || "");
      if(!dc) return;
      if(dc < start || dc > end) return;

      const carrier = fmt(b.carrier || "N/A");
      const expected = Array.isArray(b.expected_ids) ? b.expected_ids : Object.values(b.expected_ids || {});
      expected.forEach(orderId=>{
        if(!orderId) return;
        const id = String(orderId).trim();
        const st = statusFromBatch(b, id);
        const det = (b.order_details && b.order_details[id]) ? b.order_details[id] : {};
        const rec = {
          id,
          carrier,
          status: st,
          batchKey,
          batchName: fmt(b.name || batchKey),
          dateClean: dc,
          customer: fmt(det.name || ""),
          expectedContent: fmt(det.content || "")
        };
        if(!all.has(id)) all.set(id, []);
        all.get(id).push(rec);

        // carrier -> ids / batches
        const cKey = safeKey(carrier);
        if(!byCarrierIds.has(cKey)) byCarrierIds.set(cKey, new Set());
        byCarrierIds.get(cKey).add(id);
        if(!byCarrierBatches.has(cKey)) byCarrierBatches.set(cKey, new Set());
        byCarrierBatches.get(cKey).add(batchKey);

        // pick "best" for single summary:
        // prefer latest dateClean, and if tie prefer PACKED over others (so you see packed quickly)
        const prev = idx.get(id);
        const curScore = (rec.dateClean) + "|" + (rec.status==="PACKED" ? "2" : (rec.status==="PENDING" ? "1" : "0"));
        const prevScore = prev ? (prev.dateClean + "|" + (prev.status==="PACKED" ? "2" : (prev.status==="PENDING" ? "1" : "0"))) : "";
        if(!prev || curScore > prevScore) idx.set(id, rec);
      });
    });
    // sort all arrays by date
    all.forEach((arr, id)=>{
      arr.sort((a,b)=> (a.dateClean||"").localeCompare(b.dateClean||""));
    });
    state.offIndex = idx;
    state.offAllMatches = all;
    state.offCarrierIds = byCarrierIds;
    state.offBatchesByCarrier = byCarrierBatches;
  }

  // ===== Get tracking / packed record from registos in date range =====
  async function loadPackedIndex(start, end){
    state.packedIndex = new Map();

    // filter by dateClean in range (inclusive)
    let ref = db.ref("registos").orderByChild("dateClean").startAt(start).endAt(end);
    const snap = await ref.once("value");
    const reg = snap.val() || {};
    Object.values(reg).forEach(r=>{
      if(!r || !r.id) return;
      const mode = String(r.mode || "").toUpperCase();
      if(mode !== "PACKING") return;
      const id = String(r.id).trim();
      const packedAt = dt(r.dateClean, normTime(r.endTime || r.time || r.startTime));
      const rec = {
        id,
        tracking: fmt(r.track || r.tracking || ""),
        packedAt,
        user: fmt(r.user || ""),
        batchKey: fmt(r.batch || "")
      };
      // keep latest packedAt
      const prev = state.packedIndex.get(id);
      if(!prev || (rec.packedAt > prev.packedAt)) state.packedIndex.set(id, rec);
    });
  }

  // ===== Optional deep index from id_history (can be heavy) =====
  async function loadHistoryForIds(ids){
    state.histIndex = new Map();
    const jobs = ids.map(async (id)=>{
      try{
        const snap = await db.ref("id_history/" + id).once("value");
        const hist = snap.val() || {};
        const events = Object.values(hist).map(e=>({
          Type: fmt(e.Type),
          DateTime: fmt(e.DateTime) || dt(e.dateClean, e.time),
          Batch: fmt(e.Batch || e.batchName || e.BatchKey || ""),
          Carrier: fmt(e.Carrier || ""),
          User: fmt(e.User || ""),
          Tracking: fmt(e.Tracking || ""),
          Items_or_Content: fmt(e.Items_or_Content || ""),
          Details: fmt(e.Details || ""),
          ts: Number(e.ts || 0)
        }));
        events.sort((a,b)=> (a.ts||0) - (b.ts||0) || a.DateTime.localeCompare(b.DateTime));
        state.histIndex.set(id, {events});
      }catch(e){
        // ignore per id
      }
    });
    // throttle a bit: run in chunks
    const chunk = 25;
    for(let i=0;i<jobs.length;i+=chunk){
      await Promise.all(jobs.slice(i,i+chunk));
    }
  }

  // ===== RUN =====
  async function run(){
    // must be authenticated, otherwise DB rules may block
    if(!auth.currentUser){
      setStatus("Faz login primeiro.", "bad");
      openLogin();
      return;
    }

    // ensure last paste saved from current carrier box (so user doesn't forget)
    try{ saveCarrierPaste(); }catch(e){}

    const start = $("startDate").value;
    const end = $("endDate").value;
    const lookback = parseInt($("lookback").value, 10) || 0;
    const mode = $("searchMode").value;

    // effective window = start-lookback .. end
    const effStart = dateAddDays(start, -lookback);

    setStatus("A carregar dados do OFF...", "");
    $("btnRun").disabled = true;

    try{
      // 1) load active_batches in eff range
      let ref = db.ref("active_batches").orderByChild("dateClean").startAt(effStart).endAt(end);
      const snap = await ref.once("value");
      const batches = snap.val() || {};
      collectMatchesFromBatches(batches, effStart, end);

      // 2) packed tracking from registos in eff range
      await loadPackedIndex(effStart, end);

      // 3) build list of all pasted IDs
      const pasted = [];
      // carriers selecionadas (se nenhuma, usar todas com lista guardada)
      const selected = getSelectedCarriers();
      const carriersToUse = (selected && selected.length)
        ? selected
        : Object.keys(state.carrierLists || {}).filter(c => state.carrierLists[c] && state.carrierLists[c].size);

      // lista conjunta (opcional): se tiver IDs e houver 2+ carriers selecionadas, usar como grupo
      const jointEl = document.getElementById("jointIds");
      const jointIds = jointEl ? parseIds(jointEl.value) : [];
      const useJoint = jointIds.length && carriersToUse.length >= 2;

      if(useJoint){
        const groupLabel = carriersToUse.join(" + ");
        jointIds.forEach(id => pasted.push({carrier: groupLabel, id: String(id).trim(), groupCarriers: carriersToUse.slice()}));
      } else {
        carriersToUse.forEach((carrier)=>{
          const set = state.carrierLists ? state.carrierLists[carrier] : null;
          if(!set) return;
          Array.from(set).forEach(id => pasted.push({carrier, id: String(id).trim(), groupCarriers: null}));
        });
      }

      const allIds = pasted.map(x=>x.id);
      if(mode === "DEEP"){
        setStatus("Modo Profundo: a ler id_history...", "");
        await loadHistoryForIds(uniq(allIds));
      } else {
        state.histIndex = new Map();
      }

      // 4) produce results
      const rows = [];
      pasted.forEach(({carrier: inputCarrier, id})=>{
        const allMatchesAll = state.offAllMatches.get(id) || [];
        const packed = state.packedIndex.get(id);

        const groupCarriers = pasted.find(p=>p.id===id && p.carrier===inputCarrier)?.groupCarriers || null;
        const allowed = groupCarriers ? new Set(groupCarriers.map(c=>safeKey(c))) : null;

        // escolher match "dentro do grupo" se for lista conjunta
        let match = null;
        let allMatches = allMatchesAll;

        if(allowed){
          const filtered = allMatchesAll.filter(m => allowed.has(safeKey(m.carrier)));
          allMatches = filtered.length ? filtered : allMatchesAll;
          if(filtered.length){
            // escolher o melhor: mais recente e PACKED preferido
            filtered.sort((a,b)=> (a.dateClean||"").localeCompare(b.dateClean||"") || (a.status==="PACKED"?1:0) - (b.status==="PACKED"?1:0));
            match = filtered[filtered.length-1];
          } else {
            match = null;
          }
        } else {
          match = state.offIndex.get(id) || null;
        }

        let resultKind = "MISSING";
        let offCarrier = "";
        let st = "";
        let batchName = "";
        let batchKey = "";
        let dc = "";
        let tracking = "";
        let packedFlag = "";
        let note = "";

        if(match){
          offCarrier = match.carrier;
          st = match.status;
          batchName = match.batchName;
          batchKey = match.batchKey;
          dc = match.dateClean;

          if(allowed){
            // MATCH se encontrar em qualquer carrier do grupo
            resultKind = allowed.has(safeKey(offCarrier)) ? "MATCH" : "OTHER_CARRIER";
          } else {
            if(safeKey(offCarrier) === safeKey(inputCarrier)) resultKind = "MATCH";
            else resultKind = "OTHER_CARRIER";
          }

          if(packed && packed.tracking) tracking = packed.tracking;
          packedFlag = (st === "PACKED") ? "SIM" : "NÃO";

          if(st !== "PACKED" && packed){
            note = "Existe registo PACKING no intervalo (ver detalhes).";
          }
        } else {
          note = allowed
            ? "Não encontrado no OFF para as transportadoras selecionadas (intervalo)."
            : "Não encontrado em active_batches no intervalo.";
          if(mode === "DEEP" && state.histIndex.has(id)){
            note = (allowed ? "Não encontrado no grupo, mas existe id_history (ver detalhes)." : "Não encontrado em active_batches no intervalo, mas existe id_history (ver detalhes).");
          }
        }

        rows.push({
          inputCarrier, id, resultKind,
          offCarrier, status: st, batchName, batchKey, dateClean: dc,
          packedFlag, tracking, note,
          allMatches,
          packed,
          history: state.histIndex.get(id) || null
        });
      });

      // dedupe duplicates pasted within same carrier (keep row but flag)
      const seen = new Set();
      rows.forEach(r=>{
        const k = safeKey(r.inputCarrier) + "|" + r.id;
        if(seen.has(k)) r.note = (r.note ? r.note + " | " : "") + "ID duplicado na lista da transportadora.";
        else seen.add(k);
      });

      state.results = rows;
      state.lastRunMeta = { start, end, effStart, lookback, mode, total: rows.length };

      updateKPIs();
      updateOffKPIs();
      renderTable();
      setStatus("Feito ✅", "ok");
    }catch(e){
      console.error(e);
      setStatus("Erro a ler OFF (permissões / rede).", "bad");
    } finally {
      $("btnRun").disabled = false;
    }
  }
  window.run = run;

  function updateKPIs(){
    const rows = state.results || [];
    const total = rows.length;
    const match = rows.filter(r=>r.resultKind==="MATCH").length;
    const missing = rows.filter(r=>r.resultKind==="MISSING").length;
    const other = rows.filter(r=>r.resultKind==="OTHER_CARRIER").length;
    $("kpiTotal").textContent = total;
    $("kpiMatch").textContent = match;
    $("kpiMissing").textContent = missing;
    $("kpiOther").textContent = other;
  }

  // ===== OFF IDs (seleção) — para veres todos os IDs que o OFF tem mesmo que não venham na lista =====
  function computeOffSetForSelection(){
    const selected = getSelectedCarriers();
    const carriersToUse = (selected && selected.length)
      ? selected
      : Object.keys(state.carrierLists || {}).filter(c => state.carrierLists[c] && state.carrierLists[c].size);

    const carrierKeys = carriersToUse.map(c=>safeKey(c));
    const offSet = new Set();
    carrierKeys.forEach(k=>{
      const set = state.offCarrierIds && state.offCarrierIds.get(k);
      if(set) Array.from(set).forEach(id=> offSet.add(id));
    });

    // pasted union used in this run (joint or per carrier)
    const pastedUnion = new Set();
    Object.values(state.carrierLists || {}).forEach(set=>{
      if(set) Array.from(set).forEach(id=> pastedUnion.add(String(id).trim()));
    });
    // if joint box used, also include it
    const jointEl = document.getElementById("jointIds");
    if(jointEl){
      parseIds(jointEl.value).forEach(id=> pastedUnion.add(String(id).trim()));
    }

    const offInList = new Set();
    const offMissing = new Set();
    Array.from(offSet).forEach(id=>{
      if(pastedUnion.has(id)) offInList.add(id);
      else offMissing.add(id);
    });

    return { carriersToUse, offSet, offMissing, offInList };
  }

  function updateOffKPIs(){
    const x = computeOffSetForSelection();
    $("kpiOffSel").textContent = x.offSet.size;
    $("kpiOffMissing").textContent = x.offMissing.size;
    $("kpiOffInList").textContent = x.offInList.size;
    $("kpiOffCarriers").textContent = x.carriersToUse.length ? x.carriersToUse.join(" + ") : "—";
  }

  function openOffList(title, ids){
    $("offListTitle").textContent = title;
    const arr = Array.from(ids || []).sort();
    const txt = arr.join("\n");
    const html = `
      <div class="mini" style="margin-bottom:10px;">Total: <b>${arr.length}</b> (podes copiar e colar)</div>
      <div class="row" style="margin-bottom:10px;">
        <button class="btn" onclick="copyTextToClipboard('offListText')">Copiar</button>
      </div>
      <textarea id="offListText" class="mono" style="width:100%; min-height:380px;">${escapeHtml(txt)}</textarea>
    `;
    $("offListBody").innerHTML = html;
    $("offListModal").style.display = "flex";
  }

  function copyTextToClipboard(id){
    try{
      const el = document.getElementById(id);
      if(!el) return;
      el.select();
      document.execCommand("copy");
      setStatus("Copiado ✅", "ok");
    }catch(e){
      setStatus("Não consegui copiar.", "bad");
    }
  }
  window.copyTextToClipboard = copyTextToClipboard;

  function openOffMissing(){
    const x = computeOffSetForSelection();
    openOffList("IDs do OFF que NÃO estão na lista (seleção)", x.offMissing);
  }
  window.openOffMissing = openOffMissing;

  function openOffAll(){
    const x = computeOffSetForSelection();
    openOffList("TODOS os IDs do OFF (seleção)", x.offSet);
  }
  window.openOffAll = openOffAll;

  function closeOffList(){ $("offListModal").style.display="none"; }
  window.closeOffList = closeOffList;

  function updateActiveFilters(){
    const kind = $("filterKind").value;
    const q = ($("filterText").value || "").trim();
    const parts = [];
    if(kind && kind !== "ALL") parts.push("Mostrar: " + kind);
    if(q) parts.push("Texto: " + q);
    $("activeFilters").textContent = parts.length ? ("Filtro ativo → " + parts.join(" | ")) : "Sem filtros";
  }

  function clearFilters(){
    $("filterText").value = "";
    $("filterKind").value = "ALL";
    updateActiveFilters();
  try{ updateOffKPIs(); }catch(e){}
    renderTable();
  }
  window.clearFilters = clearFilters;

  // ===== Botões: Apagar tudo / Exportar / Importar (só neste ficheiro) =====
  function clearAllLocalOnly(){
    const ok = confirm("Isto vai apagar TODAS as listas guardadas neste ficheiro (localStorage), limpar resultados e filtros.\n\nNão altera o OFF.\n\nContinuar?");
    if(!ok) return;

    // limpar listas e carriers (volta a defaults)
    state.carrierLists = {};
    state.carriers = ["CTT","NACEX","CORREOS ES","CORREOS PT"];
    state.results = [];
    state.offIndex = new Map();
    state.offAllMatches = new Map();
    state.packedIndex = new Map();
    state.histIndex = new Map();
    state.lastRunMeta = {};

    clearLocalStorageAll();
    renderCarrierSelect();
    $("carrierIds").value = "";
    $("filterText").value = "";
    $("filterKind").value = "ALL";
    updateActiveFilters();
    updateKPIs();
    renderTable();
    setStatus("Tudo apagado (local) ✅", "ok");
  }

  function exportLists(){
    try{
      const obj = {
        version: 1,
        exportedAt: new Date().toISOString(),
        carriers: state.carriers || [],
        lists: Object.fromEntries(Object.entries(state.carrierLists || {}).map(([c,set])=>[c, Array.from(set||[])]))
      };
      const blob = new Blob([JSON.stringify(obj, null, 2)], {type:"application/json"});
      const a = document.createElement("a");
      a.href = URL.createObjectURL(blob);
      a.download = "crosscheck_listas_transportadoras.json";
      a.click();
      URL.revokeObjectURL(a.href);
      setStatus("Listas exportadas ✅", "ok");
    }catch(e){
      console.error(e);
      setStatus("Falha ao exportar.", "bad");
    }
  }

  function importListsFile(file){
    const reader = new FileReader();
    reader.onload = ()=>{
      try{
        const obj = JSON.parse(String(reader.result||"{}"));
        const carriers = Array.isArray(obj.carriers) ? obj.carriers : [];
        const lists = obj.lists || {};
        if(carriers.length){
          state.carriers = carriers.map(x=>String(x||"").trim().toUpperCase()).filter(Boolean);
        }
        state.carrierLists = {};
        Object.entries(lists).forEach(([c, arr])=>{
          const key = String(c||"").trim().toUpperCase();
          const ids = Array.isArray(arr) ? arr.map(x=>String(x||"").trim()).filter(Boolean) : [];
          state.carrierLists[key] = new Set(ids);
        });

        renderCarrierSelect();
        saveToLocalStorage();
        setStatus("Listas importadas ✅", "ok");
      }catch(e){
        console.error(e);
        setStatus("JSON inválido.", "bad");
      }
    };
    reader.readAsText(file);
  }

  // Wire buttons
  document.addEventListener("DOMContentLoaded", ()=>{
    const bClear = $("btnClearAll");
    const bExp = $("btnExportLists");
    const bImp = $("btnImportLists");
    const file = $("importFile");

    if(bClear) bClear.addEventListener("click", clearAllLocalOnly);
    if(bExp) bExp.addEventListener("click", exportLists);
    if(bImp) bImp.addEventListener("click", ()=> file && file.click());
    if(file){
      file.addEventListener("change", (ev)=>{
        const f = ev.target.files && ev.target.files[0];
        if(f) importListsFile(f);
        ev.target.value = "";
      });
    }
  });


  function passFilters(r){
    const kind = $("filterKind").value;
    if(kind !== "ALL" && r.resultKind !== kind) return false;

    const q = ($("filterText").value || "").trim().toLowerCase();
    if(!q) return true;

    const hay = [
      r.inputCarrier, r.id, r.resultKind, r.offCarrier, r.status,
      r.batchName, r.batchKey, r.dateClean, r.tracking, r.note
    ].join(" ").toLowerCase();
    return hay.includes(q);
  }

  function badge(kind){
    if(kind==="MATCH") return `<span class="chip"><span class="ok">●</span> BATE CERTO</span>`;
    if(kind==="OTHER_CARRIER") return `<span class="chip"><span class="warn">●</span> OUTRA CARRIER</span>`;
    return `<span class="chip"><span class="bad">●</span> NÃO ENCONTRADO</span>`;
  }

  function renderTable(){
    updateActiveFilters();
    const tbody = $("tbody");
    const rows = (state.results || []).filter(passFilters);

    tbody.innerHTML = rows.map(r=>{
      const st = r.status ? r.status : (r.resultKind==="MISSING" ? "" : "PENDING");
      const stHtml = st ? `<span class="status ${st}">${st}</span>` : `<span class="muted">-</span>`;
      const packed = r.packedFlag ? r.packedFlag : (st==="PACKED" ? "SIM" : (st ? "NÃO" : "-"));
      const trk = r.tracking ? `<span class="mono">${escapeHtml(r.tracking)}</span>` : `<span class="muted">-</span>`;
      const lote = r.batchName ? escapeHtml(r.batchName) : `<span class="muted">-</span>`;
      const dc = r.dateClean ? `<span class="mono">${escapeHtml(r.dateClean)}</span>` : `<span class="muted">-</span>`;
      const offC = r.offCarrier ? escapeHtml(r.offCarrier) : `<span class="muted">-</span>`;

      return `<tr>
        <td><b>${escapeHtml(r.inputCarrier)}</b></td>
        <td class="mono"><b>${escapeHtml(r.id)}</b></td>
        <td>${badge(r.resultKind)}${r.note ? `<div class="mini" style="margin-top:6px;">${escapeHtml(r.note)}</div>` : ""}</td>
        <td>${offC}</td>
        <td>${stHtml}</td>
        <td>${lote}</td>
        <td>${dc}</td>
        <td><b>${escapeHtml(packed)}</b></td>
        <td>${trk}</td>
        <td><span class="link" onclick="openDetail('${escapeJs(r.inputCarrier)}','${escapeJs(r.id)}')">Ver</span></td>
      </tr>`;
    }).join("");

    if(rows.length===0){
      tbody.innerHTML = `<tr><td colspan="10" class="muted" style="padding:16px;">Sem linhas para mostrar (ajusta filtros / cola IDs).</td></tr>`;
    }
  }

  function escapeHtml(s){
    return String(s||"")
      .replace(/&/g,"&amp;")
      .replace(/</g,"&lt;")
      .replace(/>/g,"&gt;")
      .replace(/"/g,"&quot;")
      .replace(/'/g,"&#39;");
  }
  function escapeJs(s){
    return String(s||"").replace(/\\/g,"\\\\").replace(/'/g,"\\'").replace(/"/g,"\\\"");
  }

  function openDetail(inputCarrier, id){
    const row = (state.results || []).find(r=> r.id===id && r.inputCarrier===inputCarrier) || null;
    if(!row){
      $("detailTitle").textContent = "Detalhe";
      $("detailBody").innerHTML = "<div class='muted'>Não encontrei este ID nos resultados atuais.</div>";
      $("detailModal").style.display="flex";
      return;
    }

    $("detailTitle").textContent = `ID ${id} — ${inputCarrier}`;
    const matches = row.allMatches || [];
    const packed = row.packed || null;
    const hist = row.history ? (row.history.events || []) : [];

    const meta = [];
    meta.push(`<div class="tag"><b>Resultado:</b> ${row.resultKind}</div>`);
    if(row.offCarrier) meta.push(`<div class="tag"><b>Carrier OFF:</b> ${escapeHtml(row.offCarrier)}</div>`);
    if(row.status) meta.push(`<div class="tag"><b>Status OFF:</b> ${escapeHtml(row.status)}</div>`);
    if(row.batchName) meta.push(`<div class="tag"><b>Lote:</b> ${escapeHtml(row.batchName)}</div>`);
    if(row.dateClean) meta.push(`<div class="tag"><b>Data lote:</b> <span class="mono">${escapeHtml(row.dateClean)}</span></div>`);

    const packedBlock = packed ? `
      <div class="card" style="padding:12px; margin-top:10px;">
        <h2 style="margin:0 0 8px 0;">Packing (registos)</h2>
        <div class="mini">
          <b>Packed at:</b> <span class="mono">${escapeHtml(packed.packedAt || "")}</span><br/>
          <b>User:</b> ${escapeHtml(packed.user || "")}<br/>
          <b>Tracking:</b> <span class="mono">${escapeHtml(packed.tracking || "")}</span><br/>
          <b>BatchKey:</b> <span class="mono">${escapeHtml(packed.batchKey || "")}</span>
        </div>
      </div>` : `
      <div class="card" style="padding:12px; margin-top:10px;">
        <h2 style="margin:0 0 8px 0;">Packing (registos)</h2>
        <div class="mini muted">Sem registo PACKING no intervalo pesquisado (ou não foi possível ler).</div>
      </div>`;

    const matchesTable = matches.length ? `
      <div class="card" style="padding:12px; margin-top:10px;">
        <h2 style="margin:0 0 8px 0;">Ocorrências em lotes (active_batches)</h2>
        <div class="tableWrap">
          <table style="min-width:760px;">
            <thead>
              <tr>
                <th>Data</th><th>Carrier</th><th>Status</th><th>Lote</th><th>BatchKey</th><th>Cliente</th><th>Conteúdo</th>
              </tr>
            </thead>
            <tbody>
              ${matches.map(m=>`
                <tr>
                  <td class="mono">${escapeHtml(m.dateClean||"")}</td>
                  <td><b>${escapeHtml(m.carrier||"")}</b></td>
                  <td><span class="status ${escapeHtml(m.status||"")}">${escapeHtml(m.status||"")}</span></td>
                  <td>${escapeHtml(m.batchName||"")}</td>
                  <td class="mono">${escapeHtml(m.batchKey||"")}</td>
                  <td>${escapeHtml(m.customer||"")}</td>
                  <td>${escapeHtml(m.expectedContent||"")}</td>
                </tr>
              `).join("")}
            </tbody>
          </table>
        </div>
      </div>` : `
      <div class="card" style="padding:12px; margin-top:10px;">
        <h2 style="margin:0 0 8px 0;">Ocorrências em lotes (active_batches)</h2>
        <div class="mini muted">Nenhuma ocorrência no intervalo pesquisado.</div>
      </div>`;

    const histBlock = hist.length ? `
      <div class="card" style="padding:12px; margin-top:10px;">
        <h2 style="margin:0 0 8px 0;">Histórico (id_history) — modo Profundo</h2>
        <div class="tableWrap">
          <table style="min-width:860px;">
            <thead>
              <tr><th>DateTime</th><th>Type</th><th>Batch</th><th>Carrier</th><th>User</th><th>Tracking</th><th>Items/Content</th><th>Details</th></tr>
            </thead>
            <tbody>
              ${hist.slice(-200).map(ev=>`
                <tr>
                  <td class="mono">${escapeHtml(ev.DateTime||"")}</td>
                  <td><b>${escapeHtml(ev.Type||"")}</b></td>
                  <td>${escapeHtml(ev.Batch||"")}</td>
                  <td>${escapeHtml(ev.Carrier||"")}</td>
                  <td>${escapeHtml(ev.User||"")}</td>
                  <td class="mono">${escapeHtml(ev.Tracking||"")}</td>
                  <td><small>${escapeHtml(ev.Items_or_Content||"")}</small></td>
                  <td><small>${escapeHtml(ev.Details||"")}</small></td>
                </tr>
              `).join("")}
            </tbody>
          </table>
        </div>
        <div class="mini muted" style="margin-top:8px;">Mostro só os últimos 200 eventos para não pesar.</div>
      </div>` : `
      <div class="card" style="padding:12px; margin-top:10px;">
        <h2 style="margin:0 0 8px 0;">Histórico (id_history)</h2>
        <div class="mini muted">Sem histórico (ou não ativaste Modo Profundo).</div>
      </div>`;

    $("detailBody").innerHTML = `
      <div>${meta.join("")}</div>
      ${row.note ? `<div class="mini" style="margin-top:10px;">${escapeHtml(row.note)}</div>` : ""}
      ${packedBlock}
      ${matchesTable}
      ${histBlock}
      <div class="card" style="padding:12px; margin-top:10px;">
        <h2 style="margin:0 0 8px 0;">Janela do último cruzamento</h2>
        <div class="mini">
          <b>Start:</b> <span class="mono">${escapeHtml(state.lastRunMeta.start||"")}</span> |
          <b>End:</b> <span class="mono">${escapeHtml(state.lastRunMeta.end||"")}</span> |
          <b>Efetivo:</b> <span class="mono">${escapeHtml(state.lastRunMeta.effStart||"")}</span> → <span class="mono">${escapeHtml(state.lastRunMeta.end||"")}</span> |
          <b>Lookback:</b> ${escapeHtml(String(state.lastRunMeta.lookback||0))} |
          <b>Modo:</b> ${escapeHtml(state.lastRunMeta.mode||"")}
        </div>
      </div>
    `;

    $("detailModal").style.display="flex";
  }
  window.openDetail = openDetail;

  function closeDetail(){ $("detailModal").style.display="none"; }
  window.closeDetail = closeDetail;

  // init
  loadFromLocalStorage();
  initDates();
  renderCarrierSelect();
  updateActiveFilters();
  // tentar carregar carriers do OFF se sessão já estiver ativa
  try{ if(firebase && firebase.auth && firebase.auth().currentUser){ loadCarriersFromOFF(); } }catch(e){}
  // mostrar última lista do carrier selecionado
  loadCarrierPasteToBox();
// Keep UI responsive if user forgets to click "Guardar lista"
  $("carrierIds").addEventListener("blur", ()=>{ try{ saveCarrierPaste(); }catch(e){} });
  const jointEl = document.getElementById("jointIds");
  if(jointEl){ jointEl.addEventListener("blur", ()=>{ try{ saveToLocalStorage(); }catch(e){} }); }

</script>
</body>
</html>
